{
  
    
        "post0": {
            "title": "Building an Orchid Genus Classifier App Using fastai, Render and Flutter",
            "content": "In this blog series I&#39;ll show how to train an orchid genus classifier using fastai, deploy this to Render and create a Flutter app for the front-end. This will be done in two parts: . Dataset Collection and fastai Image Classifier Training | Render Deployment and Flutter App | This is part 2, please see the associated github repo for further implementation details. . Render Deployment . Now that we&#39;ve trained our model, we need to deploy our learner to a dockerized environment, such that we can perform inference on new images. The fastai course v3 had a starter package for render that we&#39;ll update for the latest fastai library (version 2) and also for fastapi in this case. (Note: the fastbook and fastai website now give different options, such as a binder-hosted jupyter notebook for simple inference, or seemeai, although I find render and heroku are still very good options and more flexible than binder.) . Training a fastai Image Classifier . Training the image classifier using fastai and transfer learning is a straightforward and speedy task, with very high accuracy, thanks to the bespoke image augmentations and state-of-the-art learner implementation available out-of-the-box. . !pip install --upgrade fastai -q . from fastai.vision.all import * . Datapath setup . path = Path(&quot;/content/dataset&quot;) . Check our data . fastai provides an image verficiation function, which can help us check our dataset before we get down to the training process and realise there are corrupted images. Thankfully, after cleaning the dataset using duplicate image finders and corrupt file finders, there were none. . # test our files are findable fnames = get_image_files(path) fnames . (#6059) [Path(&#39;/content/dataset/Cymbidium/170.IMG_1049_new-1.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/166.Cymbidium-Cymbidium-spp-Ficha-T%C3%A9cnica-Y-Cuidados.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/319.Cymbidium_Mighty_Mouse_Minnie_x_Cymbidium_Lemon_Butter_Solana_Gold-830x557.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/19.cymbidium_orchid.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/251.CYMBIDIUM-ORCHID-RENES-WISH-wholesale-flowers.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/287.orquidea-cymbidium-xl-848x477x80xX-1.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/6.IMG_1793-e1538511932201.png&#39;),Path(&#39;/content/dataset/Cymbidium/283.Cymbidium-Sweetheart_d600.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/10.cymbidium-orchid-600x600.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/293.74707952-hermosa-orqu%C3%ADdea-cymbidium.jpg&#39;)...] . # check for corrupted files verify_images(fnames) . (#0) [] . Create our DataBlock and DataLoaders . A key element of the new multi-layered fastai api is the DataBlock, which is the template for the dataloader for passing data into the learner during the training stage. This combines the templates for the dataloader (item and label &quot;getters&quot;, training and validation splits, image augmentations and normalization). In addition, the CategoryBlock tells the learner to use Cross Entropy Loss (a combination of log-softmax and negative log-likelihood loss), for a single label classification. . In this case, I applied essentially the recommendations from the fastai course and fastbook, i.e.: . Presizing - i.e. take a larger section of the image on the item transforms (which creates uniform image sizes before they are passed to the GPU for batch transformations) | the *aug_transforms which are a mixture of warps, brightness and colour changes and random resizing and cropping | Normalization by the ImageNet statistics as we are using a pretrained Resnet50, with transfer learning. | . #create our datablock orchids = DataBlock(blocks=(ImageBlock, CategoryBlock), splitter=RandomSplitter(valid_pct=0.2, seed=42), get_items=get_image_files, get_y=parent_label, item_tfms=Resize(460), # Presizing batch_tfms=[*aug_transforms(size=224, min_scale=0.75), Normalize.from_stats(*imagenet_stats)]) . Having done that, we can instantiate our dataloaders (also defining the batch size) and also show a batch of very pretty images. . # make our dataloaders dls = orchids.dataloaders(path, bs=64) . # Now check our images dls.show_batch(max_n=9) . Create our Learner . Now we create our Learner, which handles the training and validation loops. In this case, we&#39;ll use a pretrained ResNet-50 from the PyTorch model zoo. The cnn_learner automatically cuts the final fully connected layers of the pretrained network (which have the original label outputs) and applies a new custom head network to the main pretrained body, with the correct amount of outputs, based on the number of labels in the dataset. . learn = cnn_learner(dls, resnet50, pretrained=True, loss_func=CrossEntropyLossFlat(), opt_func=Adam, metrics=accuracy) . Find our Learning Rate . A key element to training a neural network quickly and to high accuracy is having an optimum learning rate for the loss function optimizer (in this case Adam) at the right time during training. fastai makes choosing this learning rate and instantiating a &quot;one-cycle&quot; learning rate (i.e. a single cycle over the course of the entire training, which starts slowly, ramps up to a maximum rate and then reduces in a cosine annealing fashion to zero). In addition, this inversely cycles the momentum of the Adam optimizer. . learn.lr_find(suggestions=True) . /usr/local/lib/python3.6/dist-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data. Expecting to read 2 bytes but only got 0. warnings.warn(str(msg)) . SuggestedLRs(lr_min=0.005754399299621582, lr_steep=0.0010000000474974513) . Train Our Model . Now we&#39;ve found a good learning rate, we can train the head of our model. At this point the pretrained model&#39;s parameters are still frozen, other than the Batch Norm layers, which allows the pretrained network to act as a fixed-feature extractor for the new custom head. . Train head . learn.fit_one_cycle(10, 1e-3) . epoch train_loss valid_loss accuracy time . 0 | 2.845518 | 1.423715 | 0.599505 | 01:24 | . 1 | 1.730574 | 1.151923 | 0.693642 | 01:23 | . 2 | 1.225178 | 0.995854 | 0.725021 | 01:23 | . 3 | 0.976378 | 0.919860 | 0.746490 | 01:24 | . 4 | 0.751894 | 0.834673 | 0.772915 | 01:24 | . 5 | 0.610444 | 0.807859 | 0.784476 | 01:25 | . 6 | 0.491962 | 0.770431 | 0.780347 | 01:25 | . 7 | 0.416870 | 0.768377 | 0.791907 | 01:26 | . 8 | 0.369887 | 0.764954 | 0.796036 | 01:27 | . 9 | 0.346570 | 0.751820 | 0.799339 | 01:27 | . Unfreeze and train base layers . An accuracy of 80% is not bad for 10 epochs, given the variance of the types of species within each genus! Not bad at all. Now let&#39;s unfreeze the base model and train the fully network. . To do this we also need to find our new learning rate. . learn.unfreeze() . learn.lr_find() . SuggestedLRs(lr_min=2.290867705596611e-05, lr_steep=1.3182567499825382e-06) . Now that we&#39;ve got some idea of our new learning rate, we&#39;ll apply this using discriminative layer learning. This refers to using a lower learning rate for the base network parameters and a higher learning rate for the custom head, such that we don&#39;t &quot;damage&quot; the pre-existing parameters trained for many hours on ImageNet. . learn.fit_one_cycle(20, slice=(6e-6,6e-5)) . epoch train_loss valid_loss accuracy time . 0 | 0.453058 | 0.840666 | 0.772915 | 01:29 | . 1 | 0.651639 | 1.414684 | 0.667217 | 01:28 | . 2 | 1.032905 | 1.770493 | 0.614368 | 01:29 | . 3 | 1.065532 | 2.119179 | 0.496284 | 01:29 | . 4 | 1.099497 | 1.405346 | 0.620974 | 01:28 | . 5 | 0.964336 | 1.601728 | 0.587118 | 01:29 | . 6 | 0.923180 | 1.652808 | 0.584641 | 01:29 | . 7 | 0.867319 | 0.970786 | 0.728324 | 01:28 | . 8 | 0.805006 | 1.195390 | 0.651528 | 01:29 | . 9 | 0.647579 | 1.135085 | 0.698596 | 01:30 | . 10 | 0.591589 | 1.076413 | 0.725846 | 01:30 | . 11 | 0.526392 | 1.291697 | 0.700248 | 01:31 | . 12 | 0.432536 | 0.782687 | 0.788604 | 01:30 | . 13 | 0.302862 | 0.750325 | 0.793559 | 01:33 | . 14 | 0.241066 | 0.691607 | 0.802642 | 01:33 | . 15 | 0.177758 | 0.689294 | 0.831544 | 01:32 | . 16 | 0.130680 | 0.665458 | 0.830718 | 01:32 | . 17 | 0.100354 | 0.668383 | 0.829893 | 01:31 | . 18 | 0.092311 | 0.662804 | 0.829067 | 01:31 | . 19 | 0.073622 | 0.668779 | 0.829067 | 01:30 | . A final model performance of 83% is quite impressive! . Plot Confusion Matrix . We can also view our actual vs. predicted labels from the output of the validation set of the model. . interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix(figsize=(12,12), dpi=60) . Although we can see that Miltonia is commonly confused with Miltoniopsis (a little unsurpising, given that they were commonly lumped together by botanists until the 1970s), this is a little tricky to read given the amount of labels, so let&#39;s plot the highest losses. . We can see here that the losses are very high indeed for the errors in some cases, however, these could well be hybrids of the two generea - fortunately I know an orchid expert who can help me refine this model. For now though, we&#39;ll go deploy it, and try it in the real world on some new images and refine later. . interp.plot_top_losses(4, nrows=2, figsize=(10,10)) . Export and upload the learner to a Google Cloud Storage Bucket for the app . The next stage is to export our Learner, such that we can use it in the app for predictions. We&#39;ll also upload this to a Google Cloud Storage Bucket, such that the app script can access and download it during deployment. . learn.export() . from google.colab import auth auth.authenticate_user() # set project id project_id = &#39;project-id&#39; !gcloud config set project {project_id} # bucket name bucket_name = &#39;project-bucket-name&#39; # copy to our bucket !gsutil cp &quot;/content/export.pkl&quot; gs://{bucket_name}/ . Updated property [core/project]. Copying file:///content/export.pkl [Content-Type=application/octet-stream]... Operation completed over 1 objects/98.9 MiB. . List dependencies for Render deployment . Another critical piece of deploying an app are the dependencies - we need to make sure we&#39;re deploying the Docker container with the same library dependencies that we trained the app on. These are straightforward to see within your Notebook environment. . !pip list . Package Version -- absl-py 0.10.0 alabaster 0.7.12 albumentations 0.1.12 altair 4.1.0 argon2-cffi 20.1.0 asgiref 3.2.10 astor 0.8.1 astropy 4.0.1.post1 astunparse 1.6.3 async-generator 1.10 atari-py 0.2.6 atomicwrites 1.4.0 attrs 20.2.0 audioread 2.1.8 autograd 1.3 Babel 2.8.0 backcall 0.2.0 beautifulsoup4 4.6.3 bleach 3.1.5 blis 0.4.1 bokeh 2.1.1 boto 2.49.0 boto3 1.14.59 botocore 1.17.59 Bottleneck 1.3.2 branca 0.4.1 bs4 0.0.1 CacheControl 0.12.6 cachetools 4.1.1 catalogue 1.0.0 certifi 2020.6.20 cffi 1.14.2 chainer 7.4.0 chardet 3.0.4 click 7.1.2 cloudpickle 1.3.0 cmake 3.12.0 cmdstanpy 0.9.5 colorlover 0.3.0 community 1.0.0b1 contextlib2 0.5.5 convertdate 2.2.2 coverage 3.7.1 coveralls 0.5 crcmod 1.7 cufflinks 0.17.3 cupy-cuda101 7.4.0 cvxopt 1.2.5 cvxpy 1.0.31 cycler 0.10.0 cymem 2.0.3 Cython 0.29.21 daft 0.0.4 dask 2.12.0 dataclasses 0.7 datascience 0.10.6 debugpy 1.0.0rc2 decorator 4.4.2 defusedxml 0.6.0 descartes 1.1.0 dill 0.3.2 distributed 1.25.3 Django 3.1.1 dlib 19.18.0 dm-tree 0.1.5 docopt 0.6.2 docutils 0.15.2 dopamine-rl 1.0.5 earthengine-api 0.1.234 easydict 1.9 ecos 2.0.7.post1 editdistance 0.5.3 en-core-web-sm 2.2.5 entrypoints 0.3 ephem 3.7.7.1 et-xmlfile 1.0.1 fa2 0.3.5 fancyimpute 0.4.3 fastai 2.0.11 fastcore 1.0.9 fastdtw 0.3.4 fastprogress 1.0.0 fastrlock 0.5 fastscript 1.0.0 fbprophet 0.7.1 feather-format 0.4.1 filelock 3.0.12 firebase-admin 4.1.0 fix-yahoo-finance 0.0.22 Flask 1.1.2 folium 0.8.3 future 0.16.0 gast 0.3.3 GDAL 2.2.2 gdown 3.6.4 gensim 3.6.0 geographiclib 1.50 geopy 1.17.0 gin-config 0.3.0 glob2 0.7 google 2.0.3 google-api-core 1.16.0 google-api-python-client 1.7.12 google-auth 1.17.2 google-auth-httplib2 0.0.4 google-auth-oauthlib 0.4.1 google-cloud-bigquery 1.21.0 google-cloud-core 1.0.3 google-cloud-datastore 1.8.0 google-cloud-firestore 1.7.0 google-cloud-language 1.2.0 google-cloud-storage 1.18.1 google-cloud-translate 1.5.0 google-colab 1.0.0 google-pasta 0.2.0 google-resumable-media 0.4.1 googleapis-common-protos 1.52.0 googledrivedownloader 0.4 graphviz 0.10.1 grpcio 1.32.0 gspread 3.0.1 gspread-dataframe 3.0.8 gym 0.17.2 h5py 2.10.0 HeapDict 1.0.1 holidays 0.10.3 holoviews 1.13.3 html5lib 1.0.1 httpimport 0.5.18 httplib2 0.17.4 httplib2shim 0.0.3 humanize 0.5.1 hyperopt 0.1.2 ideep4py 2.0.0.post3 idna 2.10 image 1.5.32 imageio 2.4.1 imagesize 1.2.0 imbalanced-learn 0.4.3 imblearn 0.0 imgaug 0.2.9 importlib-metadata 1.7.0 imutils 0.5.3 inflect 2.1.0 iniconfig 1.0.1 intel-openmp 2020.0.133 intervaltree 2.1.0 ipykernel 4.10.1 ipython 5.5.0 ipython-genutils 0.2.0 ipython-sql 0.3.9 ipywidgets 7.5.1 itsdangerous 1.1.0 jax 0.1.75 jaxlib 0.1.52 jdcal 1.4.1 jedi 0.17.2 jieba 0.42.1 Jinja2 2.11.2 jmespath 0.10.0 joblib 0.16.0 jpeg4py 0.1.4 jsonschema 2.6.0 jupyter 1.0.0 jupyter-client 5.3.5 jupyter-console 5.2.0 jupyter-core 4.6.3 jupyterlab-pygments 0.1.1 kaggle 1.5.8 kapre 0.1.3.1 Keras 2.4.3 Keras-Preprocessing 1.1.2 keras-vis 0.4.1 kiwisolver 1.2.0 knnimpute 0.1.0 korean-lunar-calendar 0.2.1 librosa 0.6.3 lightgbm 2.2.3 llvmlite 0.31.0 lmdb 0.99 lucid 0.3.8 LunarCalendar 0.0.9 lxml 4.2.6 Markdown 3.2.2 MarkupSafe 1.1.1 matplotlib 3.2.2 matplotlib-venn 0.11.5 missingno 0.4.2 mistune 0.8.4 mizani 0.6.0 mkl 2019.0 mlxtend 0.14.0 more-itertools 8.5.0 moviepy 0.2.3.5 mpmath 1.1.0 msgpack 1.0.0 multiprocess 0.70.10 multitasking 0.0.9 murmurhash 1.0.2 music21 5.5.0 natsort 5.5.0 nbclient 0.5.0 nbconvert 5.6.1 nbdev 1.0.18 nbformat 5.0.7 nest-asyncio 1.4.0 networkx 2.5 nibabel 3.0.2 nltk 3.2.5 notebook 5.3.1 np-utils 0.5.12.1 numba 0.48.0 numexpr 2.7.1 numpy 1.18.5 nvidia-ml-py3 7.352.0 oauth2client 4.1.3 oauthlib 3.1.0 okgrade 0.4.3 opencv-contrib-python 4.1.2.30 opencv-python 4.1.2.30 openpyxl 2.5.9 opt-einsum 3.3.0 osqp 0.6.1 packaging 20.4 palettable 3.3.0 pandas 1.0.5 pandas-datareader 0.8.1 pandas-gbq 0.11.0 pandas-profiling 1.4.1 pandocfilters 1.4.2 panel 0.9.7 param 1.9.3 parso 0.7.1 pathlib 1.0.1 patsy 0.5.1 pexpect 4.8.0 pickleshare 0.7.5 piexif 1.1.3 Pillow 7.0.0 pip 19.3.1 pip-tools 4.5.1 plac 1.1.3 plotly 4.4.1 plotnine 0.6.0 pluggy 0.7.1 portpicker 1.3.1 prefetch-generator 1.0.1 preshed 3.0.2 prettytable 0.7.2 progressbar2 3.38.0 prometheus-client 0.8.0 promise 2.3 prompt-toolkit 1.0.18 protobuf 3.12.4 psutil 5.4.8 psycopg2 2.7.6.1 ptyprocess 0.6.0 py 1.9.0 pyarrow 0.14.1 pyasn1 0.4.8 pyasn1-modules 0.2.8 pycocotools 2.0.2 pycparser 2.20 pyct 0.4.7 pydata-google-auth 1.1.0 pydot 1.3.0 pydot-ng 2.0.0 pydotplus 2.0.2 PyDrive 1.3.1 pyemd 0.5.1 pyglet 1.5.0 Pygments 2.6.1 pygobject 3.26.1 pymc3 3.7 PyMeeus 0.3.7 pymongo 3.11.0 pymystem3 0.2.0 PyOpenGL 3.1.5 pyparsing 2.4.7 pyrsistent 0.16.0 pysndfile 1.3.8 PySocks 1.7.1 pystan 2.19.1.1 pytest 3.6.4 python-apt 1.6.5+ubuntu0.3 python-chess 0.23.11 python-dateutil 2.8.1 python-louvain 0.14 python-slugify 4.0.1 python-utils 2.4.0 pytz 2018.9 pyviz-comms 0.7.6 PyWavelets 1.1.1 PyYAML 3.13 pyzmq 19.0.2 qtconsole 4.7.7 QtPy 1.9.0 regex 2019.12.20 requests 2.23.0 requests-oauthlib 1.3.0 resampy 0.2.2 retrying 1.3.3 rpy2 3.2.7 rsa 4.6 s3transfer 0.3.3 scikit-image 0.16.2 scikit-learn 0.22.2.post1 scipy 1.4.1 screen-resolution-extra 0.0.0 scs 2.1.2 seaborn 0.10.1 Send2Trash 1.5.0 setuptools 50.3.0 setuptools-git 1.2 Shapely 1.7.1 simplegeneric 0.8.1 six 1.15.0 sklearn 0.0 sklearn-pandas 1.8.0 slugify 0.0.1 smart-open 2.1.1 snowballstemmer 2.0.0 sortedcontainers 2.2.2 spacy 2.2.4 Sphinx 1.8.5 sphinxcontrib-serializinghtml 1.1.4 sphinxcontrib-websupport 1.2.4 SQLAlchemy 1.3.19 sqlparse 0.3.1 srsly 1.0.2 statsmodels 0.10.2 sympy 1.1.1 tables 3.4.4 tabulate 0.8.7 tblib 1.7.0 tensorboard 2.3.0 tensorboard-plugin-wit 1.7.0 tensorboardcolab 0.0.22 tensorflow 2.3.0 tensorflow-addons 0.8.3 tensorflow-datasets 2.1.0 tensorflow-estimator 2.3.0 tensorflow-gcs-config 2.3.0 tensorflow-hub 0.9.0 tensorflow-metadata 0.24.0 tensorflow-privacy 0.2.2 tensorflow-probability 0.11.0 termcolor 1.1.0 terminado 0.8.3 testpath 0.4.4 text-unidecode 1.3 textblob 0.15.3 textgenrnn 1.4.1 Theano 1.0.5 thinc 7.4.0 tifffile 2020.9.3 toml 0.10.1 toolz 0.10.0 torch 1.6.0+cu101 torchsummary 1.5.1 torchtext 0.3.1 torchvision 0.7.0+cu101 tornado 5.1.1 tqdm 4.41.1 traitlets 4.3.3 tweepy 3.6.0 typeguard 2.7.1 typing-extensions 3.7.4.3 tzlocal 1.5.1 umap-learn 0.4.6 uritemplate 3.0.1 urllib3 1.24.3 vega-datasets 0.8.0 wasabi 0.8.0 wcwidth 0.2.5 webencodings 0.5.1 Werkzeug 1.0.1 wheel 0.35.1 widgetsnbextension 3.5.1 wordcloud 1.5.0 wrapt 1.12.1 xarray 0.15.1 xgboost 0.90 xkit 0.0.0 xlrd 1.1.0 xlwt 1.3.0 yellowbrick 0.9.1 zict 2.0.0 zipp 3.1.0 . And let&#39;s not forget the Python version for information. . !python --version . Python 3.6.9 . Next Up . Now that we&#39;ve trained what appears to be a well performing model, let&#39;s get on to the deployment to render and creating the front-end flutter app. .",
            "url": "https://mikful.github.io/blog/fastai/jupyter/render/flutter/2020/09/15/orchid-classifier-fastai-render-flutter-2.html",
            "relUrl": "/fastai/jupyter/render/flutter/2020/09/15/orchid-classifier-fastai-render-flutter-2.html",
            "date": " • Sep 15, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Building an Orchid Genus Classifier App Using fastai, Render and Flutter#",
            "content": "In this blog series I&#39;ll show how to train an orchid genus classifier using fastai, deploy this to Render and create a Flutter app for the front-end. This will be done in two parts: . Dataset Collection and fastai Image Classifier Training | Render Deployment and Flutter App | This is part 1, please see the associated github repo for further implementation details. . Why Orchids? . I&#39;m lucky enough to live in the beautiful country of Colombia, where the scale and breadth of the natural world is as mind-blowing as you might expect and then some. Due to knowing an orchid enthusiast I&#39;m constantly encountering incredible orchids, but quickly forget the species. So I decided to give myself a little helping hand with this by creating an orchid image classifier. . Now, you may or may not know that orchids are the largest family of plants in the world, with approximately 30,000 species and another 120,000 hybrids. Quite a tall order for any image recognition system! So, I decided to set a more modest task of a classifier for genera, rather than species, and limit myself to only 20 of the most common genera to begin with as a proof of concept (maybe I&#39;ll attempt the full 150,000 species + hybrids later... perhaps). . Data Collection . Having been a fastai user for a while I&#39;ve been following along with the just released course and fastbook, both of which are fantastic. . Detailed within the book is a data collection method using Bing Image Search, however, I had already collected this dataset a while ago, but never fully created an app around it. For the dataset collection the Google Image Downloader was used within a Jupyter Notebook, downloading images of each genus into its own folder, which was a simple yet effective solution. For each genus, a maximum of 500 images were downloaded. The dataset was then cleaned with a duplicate image finder. . Bearing in mind that within a single genus there is a huge variety of features, sizes and colours, the hope was that there were enough common features of each genus for the CNN to be able to learn useful enough common representations for a classification system. So let&#39;s get on to training... . Training a fastai Image Classifier . Training the image classifier using fastai and transfer learning is a straightforward and speedy task, with very high accuracy, thanks to the bespoke image augmentations and state-of-the-art learner implementation available out-of-the-box. . !pip install --upgrade fastai -q . from fastai.vision.all import * . Datapath setup . path = Path(&quot;/content/dataset&quot;) . Check our data . fastai provides an image verficiation function, which can help us check our dataset before we get down to the training process and realise there are corrupted images. Thankfully, after cleaning the dataset using duplicate image finders and corrupt file finders, there were none. . # test our files are findable fnames = get_image_files(path) fnames . (#6059) [Path(&#39;/content/dataset/Cymbidium/170.IMG_1049_new-1.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/166.Cymbidium-Cymbidium-spp-Ficha-T%C3%A9cnica-Y-Cuidados.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/319.Cymbidium_Mighty_Mouse_Minnie_x_Cymbidium_Lemon_Butter_Solana_Gold-830x557.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/19.cymbidium_orchid.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/251.CYMBIDIUM-ORCHID-RENES-WISH-wholesale-flowers.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/287.orquidea-cymbidium-xl-848x477x80xX-1.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/6.IMG_1793-e1538511932201.png&#39;),Path(&#39;/content/dataset/Cymbidium/283.Cymbidium-Sweetheart_d600.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/10.cymbidium-orchid-600x600.jpg&#39;),Path(&#39;/content/dataset/Cymbidium/293.74707952-hermosa-orqu%C3%ADdea-cymbidium.jpg&#39;)...] . # check for corrupted files verify_images(fnames) . (#0) [] . Create our DataBlock and DataLoaders . A key element of the new multi-layered fastai api is the DataBlock, which is the template for the dataloader for passing data into the learner during the training stage. This combines the templates for the dataloader (item and label &quot;getters&quot;, training and validation splits, image augmentations and normalization). In addition, the CategoryBlock tells the learner to use Cross Entropy Loss (a combination of log-softmax and negative log-likelihood loss), for a single label classification. . In this case, I applied essentially the recommendations from the fastai course and fastbook, i.e.: . Presizing - i.e. take a larger section of the image on the item transforms (which creates uniform image sizes before they are passed to the GPU for batch transformations) | the *aug_transforms which are a mixture of warps, brightness and colour changes and random resizing and cropping | Normalization by the ImageNet statistics as we are using a pretrained Resnet50, with transfer learning. | . #create our datablock orchids = DataBlock(blocks=(ImageBlock, CategoryBlock), splitter=RandomSplitter(valid_pct=0.2, seed=42), get_items=get_image_files, get_y=parent_label, item_tfms=Resize(460), # Presizing batch_tfms=[*aug_transforms(size=224, min_scale=0.75), Normalize.from_stats(*imagenet_stats)]) . Having done that, we can instantiate our dataloaders (also defining the batch size) and also show a batch of very pretty images. . # make our dataloaders dls = orchids.dataloaders(path, bs=64) . # Now check our images dls.show_batch(max_n=9) . Create our Learner . Now we create our Learner, which handles the training and validation loops. In this case, we&#39;ll use a pretrained ResNet-50 from the PyTorch model zoo. The cnn_learner automatically cuts the final fully connected layers of the pretrained network (which have the original label outputs) and applies a new custom head network to the main pretrained body, with the correct amount of outputs, based on the number of labels in the dataset. . learn = cnn_learner(dls, resnet50, pretrained=True, loss_func=CrossEntropyLossFlat(), opt_func=Adam, metrics=accuracy) . Find our Learning Rate . A key element to training a neural network quickly and to high accuracy is having an optimum learning rate for the loss function optimizer (in this case Adam) at the right time during training. fastai makes choosing this learning rate and instantiating a &quot;one-cycle&quot; learning rate very easy (i.e. a single cycle over the course of the entire training, which starts slowly, ramps up to a maximum rate and then reduces in a cosine annealing fashion to zero). In addition, this inversely cycles the momentum of the Adam optimizer. . learn.lr_find(suggestions=True) . /usr/local/lib/python3.6/dist-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data. Expecting to read 2 bytes but only got 0. warnings.warn(str(msg)) . SuggestedLRs(lr_min=0.005754399299621582, lr_steep=0.0010000000474974513) . Train Our Model . Now we&#39;ve found a good learning rate, we can train the head of our model. At this point the pretrained model&#39;s parameters are still frozen, other than the Batch Norm layers, which allows the pretrained network to act as a fixed-feature extractor for the new custom head. . Train head . learn.fit_one_cycle(10, 1e-3) . epoch train_loss valid_loss accuracy time . 0 | 2.845518 | 1.423715 | 0.599505 | 01:24 | . 1 | 1.730574 | 1.151923 | 0.693642 | 01:23 | . 2 | 1.225178 | 0.995854 | 0.725021 | 01:23 | . 3 | 0.976378 | 0.919860 | 0.746490 | 01:24 | . 4 | 0.751894 | 0.834673 | 0.772915 | 01:24 | . 5 | 0.610444 | 0.807859 | 0.784476 | 01:25 | . 6 | 0.491962 | 0.770431 | 0.780347 | 01:25 | . 7 | 0.416870 | 0.768377 | 0.791907 | 01:26 | . 8 | 0.369887 | 0.764954 | 0.796036 | 01:27 | . 9 | 0.346570 | 0.751820 | 0.799339 | 01:27 | . Unfreeze and train base layers . An accuracy of 80% is not bad for 10 epochs, given the variance of the types of species within each genus! Not bad at all. Now let&#39;s unfreeze the base model parameters and train the full network. . To do this we also need to find our new learning rate. . learn.unfreeze() . learn.lr_find() . SuggestedLRs(lr_min=2.290867705596611e-05, lr_steep=1.3182567499825382e-06) . Now that we&#39;ve got some idea of our new learning rate, we&#39;ll apply this using discriminative layer learning. This refers to using a lower learning rate for the base network parameters and a higher learning rate for the custom head, such that we don&#39;t &quot;damage&quot; the pre-existing parameters trained for many hours on ImageNet. . learn.fit_one_cycle(20, slice=(6e-6,6e-5)) . epoch train_loss valid_loss accuracy time . 0 | 0.453058 | 0.840666 | 0.772915 | 01:29 | . 1 | 0.651639 | 1.414684 | 0.667217 | 01:28 | . 2 | 1.032905 | 1.770493 | 0.614368 | 01:29 | . 3 | 1.065532 | 2.119179 | 0.496284 | 01:29 | . 4 | 1.099497 | 1.405346 | 0.620974 | 01:28 | . 5 | 0.964336 | 1.601728 | 0.587118 | 01:29 | . 6 | 0.923180 | 1.652808 | 0.584641 | 01:29 | . 7 | 0.867319 | 0.970786 | 0.728324 | 01:28 | . 8 | 0.805006 | 1.195390 | 0.651528 | 01:29 | . 9 | 0.647579 | 1.135085 | 0.698596 | 01:30 | . 10 | 0.591589 | 1.076413 | 0.725846 | 01:30 | . 11 | 0.526392 | 1.291697 | 0.700248 | 01:31 | . 12 | 0.432536 | 0.782687 | 0.788604 | 01:30 | . 13 | 0.302862 | 0.750325 | 0.793559 | 01:33 | . 14 | 0.241066 | 0.691607 | 0.802642 | 01:33 | . 15 | 0.177758 | 0.689294 | 0.831544 | 01:32 | . 16 | 0.130680 | 0.665458 | 0.830718 | 01:32 | . 17 | 0.100354 | 0.668383 | 0.829893 | 01:31 | . 18 | 0.092311 | 0.662804 | 0.829067 | 01:31 | . 19 | 0.073622 | 0.668779 | 0.829067 | 01:30 | . A final model performance of 83% is quite impressive! . Plot Confusion Matrix . We can also view our actual vs. predicted labels from the output of the validation set of the model. . interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix(figsize=(12,12), dpi=60) . Although we can see that Miltonia is commonly confused with Miltoniopsis (a little unsurpising, given that they were commonly lumped together by botanists until the 1970s), this is a little tricky to read given the amount of labels, so let&#39;s plot the highest losses. . We can see here that the losses are very high indeed for the errors in some cases, however, these could well be hybrids of the two genera - fortunately I know an orchid expert who can help me refine this model and perhaps I could turn it into a multi-label classifier instead of single label. For now though, we&#39;ll go deploy it, and try it in the real world on some new images and refine later. . interp.plot_top_losses(4, nrows=2, figsize=(10,10)) . Export and upload the learner to a Google Cloud Storage Bucket for the app . The next stage is to export our Learner, such that we can use it in the app for predictions. We&#39;ll also upload this to a Google Cloud Storage Bucket, such that the app script can access and download it during deployment. . learn.export() . from google.colab import auth auth.authenticate_user() # set project id project_id = &#39;project-id&#39; !gcloud config set project {project_id} # bucket name bucket_name = &#39;project-bucket-name&#39; # copy to our bucket !gsutil cp &quot;/content/export.pkl&quot; gs://{bucket_name}/ . Updated property [core/project]. Copying file:///content/export.pkl [Content-Type=application/octet-stream]... Operation completed over 1 objects/98.9 MiB. . List dependencies for Render deployment . Another critical piece of deploying an app are the dependencies - we need to make sure we&#39;re deploying the Docker container with the same library dependencies that we trained the app on. These are straightforward to see within your Notebook environment. . !pip list . Package Version -- absl-py 0.10.0 alabaster 0.7.12 albumentations 0.1.12 altair 4.1.0 argon2-cffi 20.1.0 asgiref 3.2.10 astor 0.8.1 astropy 4.0.1.post1 astunparse 1.6.3 async-generator 1.10 atari-py 0.2.6 atomicwrites 1.4.0 attrs 20.2.0 audioread 2.1.8 autograd 1.3 Babel 2.8.0 backcall 0.2.0 beautifulsoup4 4.6.3 bleach 3.1.5 blis 0.4.1 bokeh 2.1.1 boto 2.49.0 boto3 1.14.59 botocore 1.17.59 Bottleneck 1.3.2 branca 0.4.1 bs4 0.0.1 CacheControl 0.12.6 cachetools 4.1.1 catalogue 1.0.0 certifi 2020.6.20 cffi 1.14.2 chainer 7.4.0 chardet 3.0.4 click 7.1.2 cloudpickle 1.3.0 cmake 3.12.0 cmdstanpy 0.9.5 colorlover 0.3.0 community 1.0.0b1 contextlib2 0.5.5 convertdate 2.2.2 coverage 3.7.1 coveralls 0.5 crcmod 1.7 cufflinks 0.17.3 cupy-cuda101 7.4.0 cvxopt 1.2.5 cvxpy 1.0.31 cycler 0.10.0 cymem 2.0.3 Cython 0.29.21 daft 0.0.4 dask 2.12.0 dataclasses 0.7 datascience 0.10.6 debugpy 1.0.0rc2 decorator 4.4.2 defusedxml 0.6.0 descartes 1.1.0 dill 0.3.2 distributed 1.25.3 Django 3.1.1 dlib 19.18.0 dm-tree 0.1.5 docopt 0.6.2 docutils 0.15.2 dopamine-rl 1.0.5 earthengine-api 0.1.234 easydict 1.9 ecos 2.0.7.post1 editdistance 0.5.3 en-core-web-sm 2.2.5 entrypoints 0.3 ephem 3.7.7.1 et-xmlfile 1.0.1 fa2 0.3.5 fancyimpute 0.4.3 fastai 2.0.11 fastcore 1.0.9 fastdtw 0.3.4 fastprogress 1.0.0 fastrlock 0.5 fastscript 1.0.0 fbprophet 0.7.1 feather-format 0.4.1 filelock 3.0.12 firebase-admin 4.1.0 fix-yahoo-finance 0.0.22 Flask 1.1.2 folium 0.8.3 future 0.16.0 gast 0.3.3 GDAL 2.2.2 gdown 3.6.4 gensim 3.6.0 geographiclib 1.50 geopy 1.17.0 gin-config 0.3.0 glob2 0.7 google 2.0.3 google-api-core 1.16.0 google-api-python-client 1.7.12 google-auth 1.17.2 google-auth-httplib2 0.0.4 google-auth-oauthlib 0.4.1 google-cloud-bigquery 1.21.0 google-cloud-core 1.0.3 google-cloud-datastore 1.8.0 google-cloud-firestore 1.7.0 google-cloud-language 1.2.0 google-cloud-storage 1.18.1 google-cloud-translate 1.5.0 google-colab 1.0.0 google-pasta 0.2.0 google-resumable-media 0.4.1 googleapis-common-protos 1.52.0 googledrivedownloader 0.4 graphviz 0.10.1 grpcio 1.32.0 gspread 3.0.1 gspread-dataframe 3.0.8 gym 0.17.2 h5py 2.10.0 HeapDict 1.0.1 holidays 0.10.3 holoviews 1.13.3 html5lib 1.0.1 httpimport 0.5.18 httplib2 0.17.4 httplib2shim 0.0.3 humanize 0.5.1 hyperopt 0.1.2 ideep4py 2.0.0.post3 idna 2.10 image 1.5.32 imageio 2.4.1 imagesize 1.2.0 imbalanced-learn 0.4.3 imblearn 0.0 imgaug 0.2.9 importlib-metadata 1.7.0 imutils 0.5.3 inflect 2.1.0 iniconfig 1.0.1 intel-openmp 2020.0.133 intervaltree 2.1.0 ipykernel 4.10.1 ipython 5.5.0 ipython-genutils 0.2.0 ipython-sql 0.3.9 ipywidgets 7.5.1 itsdangerous 1.1.0 jax 0.1.75 jaxlib 0.1.52 jdcal 1.4.1 jedi 0.17.2 jieba 0.42.1 Jinja2 2.11.2 jmespath 0.10.0 joblib 0.16.0 jpeg4py 0.1.4 jsonschema 2.6.0 jupyter 1.0.0 jupyter-client 5.3.5 jupyter-console 5.2.0 jupyter-core 4.6.3 jupyterlab-pygments 0.1.1 kaggle 1.5.8 kapre 0.1.3.1 Keras 2.4.3 Keras-Preprocessing 1.1.2 keras-vis 0.4.1 kiwisolver 1.2.0 knnimpute 0.1.0 korean-lunar-calendar 0.2.1 librosa 0.6.3 lightgbm 2.2.3 llvmlite 0.31.0 lmdb 0.99 lucid 0.3.8 LunarCalendar 0.0.9 lxml 4.2.6 Markdown 3.2.2 MarkupSafe 1.1.1 matplotlib 3.2.2 matplotlib-venn 0.11.5 missingno 0.4.2 mistune 0.8.4 mizani 0.6.0 mkl 2019.0 mlxtend 0.14.0 more-itertools 8.5.0 moviepy 0.2.3.5 mpmath 1.1.0 msgpack 1.0.0 multiprocess 0.70.10 multitasking 0.0.9 murmurhash 1.0.2 music21 5.5.0 natsort 5.5.0 nbclient 0.5.0 nbconvert 5.6.1 nbdev 1.0.18 nbformat 5.0.7 nest-asyncio 1.4.0 networkx 2.5 nibabel 3.0.2 nltk 3.2.5 notebook 5.3.1 np-utils 0.5.12.1 numba 0.48.0 numexpr 2.7.1 numpy 1.18.5 nvidia-ml-py3 7.352.0 oauth2client 4.1.3 oauthlib 3.1.0 okgrade 0.4.3 opencv-contrib-python 4.1.2.30 opencv-python 4.1.2.30 openpyxl 2.5.9 opt-einsum 3.3.0 osqp 0.6.1 packaging 20.4 palettable 3.3.0 pandas 1.0.5 pandas-datareader 0.8.1 pandas-gbq 0.11.0 pandas-profiling 1.4.1 pandocfilters 1.4.2 panel 0.9.7 param 1.9.3 parso 0.7.1 pathlib 1.0.1 patsy 0.5.1 pexpect 4.8.0 pickleshare 0.7.5 piexif 1.1.3 Pillow 7.0.0 pip 19.3.1 pip-tools 4.5.1 plac 1.1.3 plotly 4.4.1 plotnine 0.6.0 pluggy 0.7.1 portpicker 1.3.1 prefetch-generator 1.0.1 preshed 3.0.2 prettytable 0.7.2 progressbar2 3.38.0 prometheus-client 0.8.0 promise 2.3 prompt-toolkit 1.0.18 protobuf 3.12.4 psutil 5.4.8 psycopg2 2.7.6.1 ptyprocess 0.6.0 py 1.9.0 pyarrow 0.14.1 pyasn1 0.4.8 pyasn1-modules 0.2.8 pycocotools 2.0.2 pycparser 2.20 pyct 0.4.7 pydata-google-auth 1.1.0 pydot 1.3.0 pydot-ng 2.0.0 pydotplus 2.0.2 PyDrive 1.3.1 pyemd 0.5.1 pyglet 1.5.0 Pygments 2.6.1 pygobject 3.26.1 pymc3 3.7 PyMeeus 0.3.7 pymongo 3.11.0 pymystem3 0.2.0 PyOpenGL 3.1.5 pyparsing 2.4.7 pyrsistent 0.16.0 pysndfile 1.3.8 PySocks 1.7.1 pystan 2.19.1.1 pytest 3.6.4 python-apt 1.6.5+ubuntu0.3 python-chess 0.23.11 python-dateutil 2.8.1 python-louvain 0.14 python-slugify 4.0.1 python-utils 2.4.0 pytz 2018.9 pyviz-comms 0.7.6 PyWavelets 1.1.1 PyYAML 3.13 pyzmq 19.0.2 qtconsole 4.7.7 QtPy 1.9.0 regex 2019.12.20 requests 2.23.0 requests-oauthlib 1.3.0 resampy 0.2.2 retrying 1.3.3 rpy2 3.2.7 rsa 4.6 s3transfer 0.3.3 scikit-image 0.16.2 scikit-learn 0.22.2.post1 scipy 1.4.1 screen-resolution-extra 0.0.0 scs 2.1.2 seaborn 0.10.1 Send2Trash 1.5.0 setuptools 50.3.0 setuptools-git 1.2 Shapely 1.7.1 simplegeneric 0.8.1 six 1.15.0 sklearn 0.0 sklearn-pandas 1.8.0 slugify 0.0.1 smart-open 2.1.1 snowballstemmer 2.0.0 sortedcontainers 2.2.2 spacy 2.2.4 Sphinx 1.8.5 sphinxcontrib-serializinghtml 1.1.4 sphinxcontrib-websupport 1.2.4 SQLAlchemy 1.3.19 sqlparse 0.3.1 srsly 1.0.2 statsmodels 0.10.2 sympy 1.1.1 tables 3.4.4 tabulate 0.8.7 tblib 1.7.0 tensorboard 2.3.0 tensorboard-plugin-wit 1.7.0 tensorboardcolab 0.0.22 tensorflow 2.3.0 tensorflow-addons 0.8.3 tensorflow-datasets 2.1.0 tensorflow-estimator 2.3.0 tensorflow-gcs-config 2.3.0 tensorflow-hub 0.9.0 tensorflow-metadata 0.24.0 tensorflow-privacy 0.2.2 tensorflow-probability 0.11.0 termcolor 1.1.0 terminado 0.8.3 testpath 0.4.4 text-unidecode 1.3 textblob 0.15.3 textgenrnn 1.4.1 Theano 1.0.5 thinc 7.4.0 tifffile 2020.9.3 toml 0.10.1 toolz 0.10.0 torch 1.6.0+cu101 torchsummary 1.5.1 torchtext 0.3.1 torchvision 0.7.0+cu101 tornado 5.1.1 tqdm 4.41.1 traitlets 4.3.3 tweepy 3.6.0 typeguard 2.7.1 typing-extensions 3.7.4.3 tzlocal 1.5.1 umap-learn 0.4.6 uritemplate 3.0.1 urllib3 1.24.3 vega-datasets 0.8.0 wasabi 0.8.0 wcwidth 0.2.5 webencodings 0.5.1 Werkzeug 1.0.1 wheel 0.35.1 widgetsnbextension 3.5.1 wordcloud 1.5.0 wrapt 1.12.1 xarray 0.15.1 xgboost 0.90 xkit 0.0.0 xlrd 1.1.0 xlwt 1.3.0 yellowbrick 0.9.1 zict 2.0.0 zipp 3.1.0 . And let&#39;s not forget the Python version for information. . !python --version . Python 3.6.9 . Next Up . Now that we&#39;ve trained what appears to be a well performing model, let&#39;s get on to the deployment to render and creating the front-end flutter app. .",
            "url": "https://mikful.github.io/blog/fastai/jupyter/render/flutter/2020/09/15/orchid-classifier-fastai-render-flutter-1.html",
            "relUrl": "/fastai/jupyter/render/flutter/2020/09/15/orchid-classifier-fastai-render-flutter-1.html",
            "date": " • Sep 15, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Multi-Label Auto-Tagging of Noisy Audio Using fastai2 - Part 3 - Results and Analysis",
            "content": "Welcome to part 3 of a blog series based on my Udacity Machine Learning Engineer Nanodegree Capstone project. This section defines the model implementation using the in-development fastai2 audio library and Google Cloud AI Platform notebooks. . The blog series is structured as follows, please follow the links for other sections: . Problem Definition, Proposed Solution and Data Exploration | Methodology and Implementation | Results and Analysis | Links will be provided as the series progresses. Please see the associated GitHub repository for all notebooks. . A huge thanks goes to fastai and the fastai2 audio contributors for their amazing work. . IV. Results . Model Evaluation and Validation . The procedures outlined in the above sections were used to obtain a final prediction score of 0.69788. . . ​ Fig 13. Final Prediction Score, lwl-rap . Justification . The Competition baseline score of 0.53792 was beaten by a considerable margin of 16%. The winning score of 0.75980 was not achieved, with a shortfall of 6%, however, the winning model and the top-scoring models documented 1 23 used training stages of 3x to 5x as long as the one implemented herein. . Additionally, the amount of pre-processing within the solution presented was negligible, afforded by the very impressive fastai2 audio library, whereas other solutions involved the significant extra time and storage usage of conversion from audio files to spectrogram images . As such, it is considered that the model performance is more than satisfactory for the task of auto-tagging audio files and further testing would be needed to see if it could achieve the same performance as the top-scorers. . V. Conclusion . Free-Form Visualization . One very clear visual element of the datasets is the difference in the noise level and quality of the recordings between the two datasets. This is shown clearly below: . . ​ Fig 14. Differences in noise level between Curated and Noisy Set . The impact of this was that, when using the noisy dataset for training alone, the lwl-rap score was approximately 20% lower than using only the curated dataset for training. As such, the two stage training method was used for bigger performance gains. . Reflection . The stages involved in the production of this model were varied, each step requiring careful consideration of the data and audio file to spectrogram augmentations. . The most interesting aspects of the project were considered to be the time/performance cost balance required in the data augmentations’ effect on the training. It was extremely interesting to also see the stark impact of the K-Folds Validation training procedure and Test-Time-Augmentations on the final score. . The main difficulties in the project were the balancing of trying to achieve a good score while minimising training and iteration costs on the Google Cloud Platform. Given the nature of the problem, the training times were necessarily long and this was not anticipated fully at the outset of choosing the problem set. In a production setting this would be a significant consideration to bear in mind. . The final model is considered to be of good performance and will serve to inform future model development for production-stage inference of audio auto-tagging. Naturally, the TTA and ensembling of predictions means this model should only be used in an offline scenario for complex and noisy audio tagging, however, it should be noted that using this system with a standard multi-label accuracy metric, a score of over 95% was achieved within the first few epochs of training on both the Curated and Noisy Train sets. . As such, a similar approach, perhaps using a different metric (standard multi-label accuracy), could be used for a deployed inference model to be used within applications for audio classification e.g. for bird sounds, which is an area of interest of the author. . Improvement . It is considered the final prediction score could be improved in a number of ways: . Longer training times | Further fine-tuning of the mel-spectrogram settings | further ensembling of models | further data engineering, such as further training on correctly predicted noisy data 2 | . The majority of the techniques were implemented within the development of the model, however, in the best performing models in the competition, more advanced data engineering was undertaken such as cross-referencing prediction scores between models and only doing further training on the audio files that were correctly selected over a certain threshold across models. This would require significant extra development that the author did not achieve within the time frame available. . Conclusion . That concludes the 3 part series on my Udacity Machine Learning Engineer Nanodegree Capstone project. It was a fantastic learning experience and I hope one that is also useful for others. . If you have any questions or feedback about this post, I’d be very happy to hear them. Please contact me at my GitHub or Twitter using the links below. . References: . https://github.com/lRomul/argus-freesound &#8617; . | https://github.com/ebouteillon/freesound-audio-tagging-2019 &#8617; &#8617;2 . | https://medium.com/@mnpinto/multi-label-audio-classification-7th-place-public-lb-solution-for-freesound-audio-tagging-2019-a7ccc0e0a02f &#8617; . |",
            "url": "https://mikful.github.io/blog/deep%20learning/fastai2/audio/markdown/2020/06/19/Udacity-Capstone-Part-3-Results-and-Analysis.html",
            "relUrl": "/deep%20learning/fastai2/audio/markdown/2020/06/19/Udacity-Capstone-Part-3-Results-and-Analysis.html",
            "date": " • Jun 19, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Multi-Label Auto-Tagging of Noisy Audio Using fastai2 - Part 2 - Methodology and Implementation",
            "content": "Welcome to Part 2 of a blog series based on my Udacity Machine Learning Engineer Nanodegree Capstone project. This section defines the model implementation using the in-development fastai2 audio library and Google Cloud AI Platform notebooks. . The blog series is structured as follows, please follow the links for other sections: . Problem Definition, Analysis, Methods and Algorithms | Methodology and Implementation | Results and Analysis | Links will be provided as the series progresses. Please see the associated GitHub repository for all notebooks. . A huge thanks goes to fastai and the fastai2 audio contributors for their amazing work. . &nbsp; . IV. Methodology and Implementation . Data Pre-processing . Fastai2 Audio . The remarkable in-development fastai2 audio package was used to convert the audio files into mel-spectrogram 2D tensors on-the-fly, as a form of highly efficient data processing, rather than pre-processing and having to save spectrograms to a different dataset. This was done using the following process: . Create Pandas DataFrames for the files, suing the train_curated.csv and train_noisy.csv files provided by the competition, removing corrupted or empty files as given in the competition guidance: | def create_train_curated_df(file, remove_files=[]): df_curated = pd.read_csv(file) df_curated[&#39;fname&#39;] = &#39;../data/train_curated/&#39; + df_curated[&#39;fname&#39;] df_curated.set_index(&#39;fname&#39;, inplace=True) df_curated.loc[remove_files] df_curated.drop(index=remove_files, inplace=True) df_curated.reset_index(inplace=True) return df_curated def create_train_noisy_df(file): df_noisy = pd.read_csv(file) df_noisy[&#39;fname&#39;] = &#39;../data/train_noisy/&#39; + df_noisy[&#39;fname&#39;] return df_noisy # Create Curated training set df # Remove corrupt and empty files as per Kaggle guidance remove_files = [&#39;f76181c4.wav&#39;, &#39;77b925c2.wav&#39;, &#39;6a1f682a.wav&#39;, &#39;c7db12aa.wav&#39;, &#39;7752cc8a.wav&#39;, &#39;1d44b0bd.wav&#39;] remove_files = [&#39;../data/train_curated/&#39; + i for i in remove_files] df_curated = create_train_curated_df(&#39;../data/train_curated.csv&#39;, remove_files=remove_files) df_curated.head() . The DataFrames were then used to supply the fastai DataBlock API with the filenames, which could then be processed using the fastai2 audio item_transformations which are applied to each file before training. After significant testing iterations the audio transformation settings were chosen as follows: . DBMelSpec = SpectrogramTransformer(mel=True, to_db=True) # convert to Mel-spectrograms clip_length = 2 # clip subsection length in seconds sr = 44100 # sample rate f_min = 20 # mel-spectrogram minimum frequency f_max = 20000 # mel-spectrogram minimum frequency n_mels = 128 # mel-frequency bins, dictates the y-axis pixel size hop_length = math.ceil((clip_length*sr)/n_mels)# determines width of image. for square to match n_mels, set math.ceil((clip_length*sr)/n_mels) nfft = n_mels * 20 # = 2560 for higher resolution in y-axis win_length = 1024 # sample windowing top_db = 60 # highest noise level in relative db . The top_db parameter setting of 60dB was important, as the noisy train set had high background noise (low signal-to-noise ratio) which with a higher setting lead to obscured features in the mel-spectrograms. | . In addition to the mel-spectrogram settings above, the following additional item transformations were undertaken: . RemoveSilence - Splits the original signal at points of silence more than 2 * pad_ms . | CropSignal - Crops a signal by clip_length seconds and adds zero-padding by default if the signal is less than clip_length . | aud2spec - The mel-spectrogram settings from above . | MaskTime - Uses Google’s SpecAugment1 time masking procedure to zero-out time domain information as a form of data augmentation . | MaskFreq - Uses Google’s SpecAugment1 frequency masking procedure to zero-out frequency domain information as a form of data augmentation . | . item_tfms = [RemoveSilence(threshold=20), CropSignal(clip_length*1000), aud2spec, MaskTime(num_masks=1, size=8), MaskFreq(num_masks=1, size=8)] . Batch Transforms . In addition to the item transforms above, Batch Transforms were used as part of the DataBlock API, which are transformations applied per batch during training: . Normalize() - normalizes the data taking a single batch’s statistics | RatioResize(256) - during training (other than the first 10 epochs of the noisy data for speed), the mel-spectrogram tensors were resized from 128x128px to 256x256px through bilinear interpolation as this has been shown to give gains in performance over simply creating a 256x256 tensor from the outset. | Brightness and Contrast augmentations were also applied in the training cycles to improve performance | . batch_tfms = [Normalize(), RatioResize(256), Brightness(max_lighting=0.2, p=0.75), Contrast(max_lighting=0.2, p=0.75)] . No further augmentations were applied as would otherwise be typical in many image classification processes. Many typical image augmentations applied are not suitable for spectrogram representations of audio, for example, cropping/warping/rotating the spectrogram tensor would warp the relative frequency relationship and thus, would not gain any benefit at testing time. This was found to be true during tests of various transforms. . The above augmentations (prior to batch transformations), produced the following mel-spectrograms as 2D tensors (note the time and frequency masking augmentations): . &nbsp; . . Fig 8. Augmented Mel-spectrograms . &nbsp; . Implementation . The data augmentations stated above were used to significantly improve the performance of the classifier during the following K-Fold training cycles. . The implemented training method was chosen based on the Competitions 6th place winner’s technique1, however, only the first two stages were implemented as follows due to the cost requirements using GCP: . &nbsp; . . Fig 9. Train-Test-Prediction Stages . &nbsp; . Stage 1 - Noisy Training Set . As can be seen below, the following 5-Fold training cycle was used on the noisy set. The indices of the DataFrame were shuffled to ensure the data splits were chosen at random, but without overlap using SKLearn’s k-Folds module. The cycle began with 10 epochs of training at a higher learning rate and then 10 epochs of training at a lower learning rate (set after using fastai’s learning rate finder during the testing stage) used to fine-tune the model’s weights further. Please see the associated Jupyter Notebook for the training output. . The models were then saved for further training on the curated training set. . Note: No MixUp augmentations were used on the Noisy Training set. . from sklearn.model_selection import KFold # Declare Number Folds n_splits = 5 kf = KFold(n_splits=n_splits, random_state=42, shuffle=True) # random_state for repeatable results, shuffle indices df = df_noisy # to use random subset, use df = df_.sample(frac=0.5, replace=False, random_state=1) # take random subset of the noisy dataframe for faster training (otherwise need 6.5 hours for all folds with complete dataset) for fold, (train_idx, valid_idx) in enumerate(kf.split(df)): print(f&#39; nNoisy Train Set - Fold {fold+1}/{n_splits}&#39;) def get_x(r): return r[&#39;fname&#39;] def get_y(r): return r[&#39;labels&#39;].split(&#39;,&#39;) # split labels on &#39;,&#39; def get_dls(train_cycle): if train_cycle == 1: batch_tfms = [Normalize(), Brightness(max_lighting=0.2, p=0.75), Contrast(max_lighting=0.2, p=0.75)] elif train_cycle == 2: batch_tfms = [Normalize(), RatioResize(256), # progressive resize to 256x256px Brightness(max_lighting=0.2, p=0.75), Contrast(max_lighting=0.2, p=0.75)] dblock = DataBlock(blocks=(AudioBlock, MultiCategoryBlock), splitter=IndexSplitter(valid_idx), # split using df index get_x=get_x, get_y=get_y, item_tfms = item_tfms, batch_tfms = batch_tfms ) return dblock.dataloaders(df, bs=64) dls = get_dls(train_cycle=1) dls.show_batch(max_n=6) model = xresnet50(pretrained=False, act_cls=Mish, sa=True, c_in=1, n_out=80) #create custom xresnet: 1 input channel, 80 output nodes, self-attention, Mish activation function model = convert_MP_to_blurMP(model, nn.MaxPool2d) # convert MaxPool2D layers to MaxBlurPool learn = Learner(dls, model=model, loss_func=BCEWithLogitsLossFlat(), opt_func = ranger, metrics=[lwlrap]) # pass custom model to Learner, no mixup for noisy set as fewer epochs learn.fit_flat_cos(10, lr=3e-3) print(&#39;Batch transforming images to 256x256px and training further.&#39;) dls = get_dls(train_cycle=2) learn.dls = dls learn.fit_flat_cos(10, lr=3e-3/3) print(&#39;Saving Learner...&#39;) learn.save(f&#39;stage-1_noisy_fold-{fold+1}_sota2&#39;) . Stage 2 - Curated Train Set . After all 5 models had been trained on the Noisy set, the models were then trained on different 5-folds of the Curated Set. This essentially gave 5 distinct models, all trained on different data for later ensembling. . Note: MixUp data augmentations were applied to the Curated Train set, shown as training callback below. This is whereby two spectrogram tensors are combined into a single 2D tensor with a certain percentage blend (50% in this case), allowing the network to learn double the amount of features and labels per batch. This also provides a form of regularization for the model which improves generalization on the validation/test sets. . ## K-Folds training loop df = df_curated for fold, (train_idx, valid_idx) in enumerate(kf.split(df)): print(f&#39; nCurated Train Set - Fold {fold+1}/{n_splits}&#39;) def get_x(r): return r[&#39;fname&#39;] def get_y(r): return r[&#39;labels&#39;].split(&#39;,&#39;) # split labels on &#39;,&#39; dblock = DataBlock(blocks=(AudioBlock, MultiCategoryBlock), splitter=IndexSplitter(valid_idx), # split using df index get_x=get_x, get_y=get_y, item_tfms = item_tfms, batch_tfms = batch_tfms # including RatioResize(256) ) dls = dblock.dataloaders(df, bs=64) dls.show_batch(max_n=3) print(f&#39; nLoading Stage 1 model - fold {fold+1}.&#39;) model = xresnet50(pretrained=False, act_cls=Mish, sa=True, c_in=1, n_out=80) #create custom xresnet: 1 input channel, 80 output nodes, self-attention, Mish activation function model = convert_MP_to_blurMP(model, nn.MaxPool2d) # convert MaxPool2D layers to MaxBlurPool learn = Learner(dls, model=model, loss_func=BCEWithLogitsLossFlat(), opt_func=ranger, metrics=[lwlrap]) # pass custom model to Learner, no mixup for noisy set as fewer epochs learn.load(f&#39;stage-1_noisy_fold-{fold+1}_sota2&#39;) learn.dls = dls learn.add_cb(MixUp()) # add mixup callback print(&#39; nTraining on Curated Set:&#39;) learn.fit_flat_cos(50, 3e-4) print(&#39;Saving model...&#39;) learn.save(f&#39;stage-2_curated_fold-{fold+1}_sota2&#39;) . Testing . At the testing stage, Test-Time-Augmentations and ensembling the predictions of all 5 different Stage-2 models were used to improve the final predictions. . # grab test filenames from submission csv df_fnames = pd.read_csv(&#39;../data/sample_submission.csv&#39;) fnames = df_fnames.fname df_fnames = &#39;../data/test/&#39; + df_fnames.fname print(df_fnames[:5]) # get predictions for fold in range(n_splits): stage = 2 print(f&#39;Getting predictions from stage {stage} fold {fold+1} model.&#39;) learn = learn.load(f&#39;stage-2_curated_fold-{fold+1}_sota2&#39;) dl = learn.dls.test_dl(df_fnames) # predict using tta preds, targs = learn.tta(dl=dl) preds = preds.cpu().numpy() if fold == 0: predictions = preds else: predictions += preds # Average predictions predictions /= n_splits # Create Submission DataFrame df_sub = pd.DataFrame(predictions) df_sub.columns = learn.dls.vocab df_sub.insert(0, &quot;fname&quot;, 0) df_sub.fname = fnames df_sub.head() . The produced .csv file was then submitted to Kaggle. . Refinement . Initial Model . The initial CNN architecture used was a pre-trained (on ImageNet) xresnet50 model for speed of iteration. This was trained on a single fold smaller subset of the Noisy data (ranging from 20-80% using the DataBlock API - RandomSubsetSplitter()function) used for faster iteration on the noisy subset, while all of the Curated data was used. The data augmentation settings were slightly different however, as non-square mel-spectrograms were used to see if larger spectrograms could give improved scores, which was the case, however, this was at the expense of training time. . This highest score achieved by any initial model, was an lwl-rap of 0.61013 on the test-set: . &nbsp; . . Fig 10. Initial Best Score . &nbsp; . This score, while not bad for a small amount of testing and still beating the competition baseline, was far from achieving near state-of-the-art performance. . Test-Time-Augmentation was shown to provide a benefit of &gt;3% improvement during further testing rounds using a single training fold on the noisy and curated datasets, shown as the top score in the following image: . &nbsp; . . Fig 11. Improvement using TTA . &nbsp; . After reading further the writeups of the competition winners and high scorers 234, it was decided that a K-Folds validation approach was required in order to substantially improve the performance. . In addition, due to the large size of the spectrograms in the initial testing phase that would cause extremely slow training over so many folds (a 5x increase in epochs), these were replaced with smaller 128x128px (using 128 mel-bins and the settings shown in the above Data Pre-processing section). It was decided to first try training for a single fold on the Noisy set (90%/10% train/test split) and then split this model into 5 separate models for the further training on the Curated Set. . What’s more, the pretrained xresnet50 model was replaced by the state-of-the-art xresnet50 model described in the previous Section II: Algorithms and Techniques. This was in line with the allowance of only non-pretrained models in the competition and was also shown to provide small improvements over the pretrained xresnet50 over long enough training cycles, such that the non-trained units could effectively learn, as shown below: . &nbsp; . . Fig 12. Improvement using SOTA model . &nbsp; . Finally, a full 5-Fold Cross-Validation training was undertaken for both the Noisy and Curated set as detailed in Figure 9 in the Implementation section above, with some tweaks to the spectrograms settings, i.e. using top_dB of 60 to ensure only the most prominent Noisy Set features were captured by the mel-spectrograms. This this approach achieved the final score of 0.69788, a marked improvement that would have gained a bronze-medal position in the competition and could certainly be improved upon further. . Up Next . In Part 3 of this blog series, we’ll look at the final results and how these could be improved upon. . If you have any questions or feedback about this post, I’d be very happy to hear them. Please contact me at my GitHub or Twitter using the links below. . References: . Chan,Zhang,Chiu, Zoph,Cubuk,Le - 2019 - SpecAugment: A Simple Data Augmentation Method for Automatic Speech Recognition &#8617; &#8617;2 &#8617;3 . | https://github.com/lRomul/argus-freesound &#8617; . | https://github.com/ebouteillon/freesound-audio-tagging-2019 &#8617; . | https://medium.com/@mnpinto/multi-label-audio-classification-7th-place-public-lb-solution-for-freesound-audio-tagging-2019-a7ccc0e0a02f &#8617; . |",
            "url": "https://mikful.github.io/blog/deep%20learning/fastai2/audio/markdown/2020/06/12/Udacity-Capstone-Part-2-Implementation.html",
            "relUrl": "/deep%20learning/fastai2/audio/markdown/2020/06/12/Udacity-Capstone-Part-2-Implementation.html",
            "date": " • Jun 12, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Multi-Label Auto-Tagging of Noisy Audio Using fastai2 - Part 1 - Problem Definition, Data Analysis, Methods and Algorithms",
            "content": "Welcome to Part 1 of a blog series based on my Udacity Machine Learning Engineer Nanodegree Capstone project. This initial section deals with the problem definition, outlines the solution approach using the in-development fastai2 audio library and discusses the dataset. . The blog series will be structured as follows: . Problem Definition, Data Analysis, Methods and Algorithms | Methodology and Implementation | Results and Analysis | Links will be provided as the series progresses. Please see the associated GitHub repository for all notebooks. . A huge thanks goes to fastai and the fastai2 audio contributors for their amazing work. . &nbsp; . I. Problem Definition . Overview . The sub-field of Machine Learning known as Machine Listening is a burgeoning area of research using signal processing for the automatic extraction of information from sound by a computational analysis of audio. There are many different areas of research within this field as demonstrated by the latest Detection and Classification of Acoustic Scenes and Events (DCASE) 2020 Challenge1, a machine learning challenge dedicated to the research and development of new methods and algorithms for audio. These include: . Acoustic Scene Classification | Sound Event Detection and Localization | Sound Event Detection and Separation in Domestic Environments | Urban Sound tagging | Automated Audio Captioning | . As an acoustic engineer, I am extremely intrigued by this new field. Recent developments in machine learning algorithms have allowed significant progress to be made within this area, with the potential applications of the technology being wide and varied and meaning the tools could prove to be extremely useful for the acoustic practitioner amongst many other uses. . The in-development user-contributed fast.ai2 Audio library2 inspired me to undertake the development of a deep learning audio-tagging system for this Udacity Capstone project, described herein. . Problem Statement . The Freesound Audio Tagging 2019 Kaggle Competition provides the basis for my research project3. . The challenge is to develop a system for the automatic classification of multi-labelled audio files within 80 categories, that could potentially be used for automatic audio/video file tagging with noisy or untagged audio data. This has historically been investigated in a variety of ways: . Conversion of audio to mel-spectrogram images fed into CNNs | End-to-End Deep learning | Custom architectures involving auto-encoders | Features representation transfer learning with custom architectures and Google’s Audioset | . In addition, the classification of weakly labelled data from large-scale crowdsourced datasets provides a further problem for investigation4. The problem is clearly quantifiable in that a number of accuracy metrics could be used to quantify the accuracy of the model’s predictions, described below. . The competition dataset comprises audio clips from the following existing datasets: . “Curated Train Set” - Freesound Dataset (FSD): a smaller dataset collected at the MTG-UPF based on Freesound content organized with the AudioSet Ontology and manually labelled by humans. 4964 files. | “Noisy Train Set” - The soundtracks of a pool of Flickr videos taken from the Yahoo Flickr Creative Commons 100M dataset (YFCC) which are automatically labelled using metadata from the original Flickr clips. These items therefore have significantly more label noise than the Freesound Dataset items. 19815 files. | . The data comprises 80 categories labelled according to Google’s Audioset Ontology 3 with ground truth labels provided at the clip level. The clips range in duration between 0.3 to 30s in uncompressed PCM 16 bit, 44.1kHz mono audio files. . Solution Statement . With the above competition requirements in mind, the proposed solution was followed and was undertaken initially within a Pytorch AWS SageMaker notebook instance using Jupyter Notebooks, and further, using a Google Cloud Platform AI Notebook using fastai2 and fastai2 audio libraries , due to the extra credits required for the long training times on a GPU instance: . The data will be downloaded from Kaggle into the chosen platform AWS SageMaker / GCP AI Notebook instance | Exploratory Data Analysis - The dataset will be downloaded such that the file metadata can be extracted, in order to confirm: sample rates, bit-rates, durations, channels (mono/stereo) for each file in order to direct initial signal processing stage and approach towards the dataset splitting. In addition, the statistics of the file labels will be analysed. | Model Development: The fastai2 and fastai2 audio libraries will be installed | The fastai2 audio library will be used for the data processing, in order to convert the audio files into tensor representations of mel-spectrograms on-the-fly, rather than in a separate pre-processing stage. This is a significant benefit of the library in terms of allowing quick experimentation and iteration within the model development over other methods such as converting all audio files to mel-spectrogram images separately. | In-line with the competition rubric, a non-pretrained convolutional neural network (CNN) using the fastai2 library for PyTorch will be developed using state-of-the-art methods and additions. | The model will be trained on the “Noisy Train” set in a 5-Folds Cross Validation manner, using Sci-Kit Learn’s K-Fold model selection module5. | The results of these 5 models will be used to train on the “Curated Train” set in the same 5-Folds Cross Validation manner as the Curated Train set in order to gain 5 separate models. | Test-Time-Augmentation (TTA) will be used to gain averaged predictions from all 5 final models on the test set. The predictions will be submitted as a Late-Submission for the analysis of the results. | This will be repeated, with tweaks to the model augmentations in order to try to improve the results iteratively. | . | Metrics . Due to the advancement of multi-label audio classification in recent years, a simple multi-label accuracy metric was not used within the Kaggle competition, as performances of the systems can easily exceed 95% within a few epochs of training. . As such, the competition used label-weighted label-ranking average precision (a.k.a lwl-rap) as the evaluation metric. The basis for the metric, the label-ranking average precision algorithm, is described in detail within the Sci-Kit Learn implementation6. The additional adaptations of the metric are to provide the average precision of predicting a ranked list of relevant labels per audio file, which is a significantly more complex problem to solve than a standard multi-label accuracy metric. The overall score is the average over all the labels in the test set, with each label having equal weight (rather than equal weight per test item), as indicated by the “label-weighted” prefix. This is defined as follows7: . &nbsp; . lwlrap=1∑s∣C(s)∣∑a∑eϵ C(s)Prec(s,c)lwlrap = frac{1}{ sum_{s} left | C(s) right |} sum_{a} sum_{e epsilon C(s)}Prec(s,c)lwlrap=∑s​∣C(s)∣1​a∑​eϵ C(s)∑​Prec(s,c) . &nbsp; . where Prec(s,c)Prec(s,c)Prec(s,c) is the label-ranking precision for the list of labels up to class ccc and the set of ground-truth classes for sample sss is C(s)C(s)C(s). ∣C(s)∣ mid C(s) mid∣C(s)∣ is the number of true class labels for sample sss. . The Kaggle competition provides a Google Colab example implementation8. . II. Analysis . Data Exploration . The datasets were downloaded from Kaggle using the Kaggle API and analysed within a Jupyter Notebook. . The first stage of the process was to understand the dataset more fully. Fortunately, due to being a Kaggle Competition dataset it was well documented and clean in terms of organization. . Downloading the dataset was undertaken using guidance given within the Kaggle Forums9 directly into the SageMaker/GCP Instance storage for easy access. . The files were then unzipped for the EDA. For further details, please see the notebook directly. . Pandas and Pandas Profiling . In order to undertake the analysis of the data, the numerical data analysis packages Pandas and Pandas Profiling were used. . Pandas Profiling10 is an extremely useful add-on package to Pandas, which creates HTML profile reports directly from Pandas DataFrames quickly and easily. From the provided .csv files file category labels were analysed and, in addition, the audio file meta-data was extracted (i.e. sample rates, bit-rates, durations, number of channels). . &nbsp; . . Fig 1. An example Pandas DataFrame of extracted audio file info . &nbsp; . Using these two packages the following was found. . Curated Train Data . For the Curated Train dataset, it was found that the bit-rate was a constant 16bits, the channels a constant 1 (mono), constant sample rate of 44.1kHz and that there were 213 different tagging combinations of the 80 audio labels over the total file count (4964 files): . &nbsp; . . Fig 2. Pandas Profiling for the Curated Train Data set . &nbsp; . In terms of the file durations, the average file length was 7.63 seconds and the files ranged between just over 0 and 30 seconds long, with the lengths predominantly in the 0-5 seconds length range. This will affect the mel-spectrogram processing of the data, i.e. we will need to ensure a sufficient amount of both the longer and smaller audio files are taken, in order for the feature learning of the CNN to be accurate. . &nbsp; . . Fig 3. Pandas Profiling information for the audio file durations . &nbsp; . Noisy Train Data . As with the Curated dataset, with the Noisy Train dataset it was found that the bit-rate was a constant 16bits, the channels a constant 1 (mono), constant sample rate of 44.1kHz. However, in this dataset there were 1168 different tagging combinations of the 80 audio labels over the total file count (19815 files): . &nbsp; . . Fig 4. Pandas Profiling for the Noisy Train dataset . &nbsp; . The Noisy Train dataset average file length was significantly longer on average than the Curated set at 14.6s long, however, the files ranged between 1 and 16 seconds long. There is therefore a significant difference in terms of length between the two datasets. . &nbsp; . . Fig 5. Pandas Profiling information for the audio file durations . &nbsp; . In addition, as the name implies, the Noisy Train set files have a significantly higher noise floor than the Curated Train set due to the provenance of the files. . Data Visualisation . The following figure clearly illustrates the differences between the difference in durations of audio files between the two datasets: . &nbsp; . . Fig 6. Train vs Noisy dataset durations (x-axis = seconds) . &nbsp; . Therefore, in the development of the model the following factors will need to be considered: . Noise floor differences between the curated and noisy train set will affect how the signals are clipped to shorter lengths to feed into the CNN. | The average lengths also have a high range of values both over the the individual datasets and between the curated and noisy set, we will need to ensure the main recorded features corresponding to the file labels of each recording are kept within any clipped sections to produce the mel-spectrograms. | . III. Algorithms and Techniques . Mel-Spectrograms . This signal processing stage will involve trimming (to ensure uniform duration) in order be converted to uniform length log-mel-spectrogram representations of the audio. A log-mel-spectrogram is a spectrogram representation of the audio i.e. a frequency-domain representation based on the Fourier Transform (x-axis = time, y axis = frequency and colour depth/pixel value = relative sound intensity) which has been converted to the Mel scale on the y-axis by a non-linear transform in order to be more representative of the highly non-linear magnitude and frequency sensitivities of the human hearing11. The chosen settings will be discussed and shown further in the Data Preprocessing section. . &nbsp; . . Fig 7. Conversion from Waveform to Mel-spectrogram representation . &nbsp; . Convolutional Neural Network (CNN) . The length uniformity of the audio clips in is important, as it allows Rank-2 tensors of the mel-spectrograms to be fed in batches into the CNN. The model variety used was as follows, based on the state of the art findings of the fastai community12 and other research described below. The model and architecture used the following settings: . Architecture: fastai2’s XResNet50 based on the Bag of Tricks13 research paper which includes tweaks to the optimisation methods for higher performance. ResNets use skip connections in order to allow propagation of information more deeply into the architecture, giving significant speed improvements for deeper networks while allowing the gradient descent to backpropagate through the network efficiently which aids in increasing training accuracy. This has further been augmented in the Bag of Tricks paper, whereby the residual block convolutional layers have been re-arranged such that further efficiency gains are made. . | Activation Function: Mish14 which has been shown to provide performance improvements over the standard ReLU activation function due to its smoothing of the activations rather than the cut-off of the ReLU function for values below 0. . | Optimizer Function: Ranger which is a combination of the RAdam15 and Lookahead16 optimizer functions. These functions work as a searching pair, whereby one learner goes ahead of the other to explore the function topography, such that traps involving local minima can be avoided. . | Layer tweaks: Self-Attention Layers17 which allow the network to focus on a subset on the features learned to be most pertinent to the data label. . | Replacing Max Pooling Layers with “MaxBlurPool” layers for better generalization . | Flat-Cosine decay learning rate scheduling . | . K-Folds Validation . Sci-Kit Learn’s KFolds Validation function was used to split the datasets into 5 folds, to allow all of the available data to be used in the training and to further allow the 5 created models to give ensembled predictions on the Test set, which provides a significant performance improvement over a single model. . MixUp . MixUp, whereby two spectrograms are combined to form a third, was also used during the longer Curated Training Set procedure. Detailed further below. . Test-Time Augmentation (TTA) . In addition to the methods outlined above, Test-Time Augmentations were applied to the test set, whereby, during inference, multiple augmented versions of the images were created using the same data transformations as the training procedure and then the average of the maximum of the predictions for each augmented version is used as the final prediction. This provided a further performance boost. . Benchmark . The Baseline performance for the Kaggle Competition was set at 0.53792 which provided a minimum target. The winner18 of the competition achieved 0.75980, which provided the upper target. The details of the winning model and training method can be found on the linked GitHub page, but for brevity, the basic details of the system from the GitHub repo, were as follows: . Log-scaled mel-spectrograms | CNN model with attention, skip connections and auxiliary classifiers | SpecAugment, Mixup augmentations | Hand relabeling of the curated dataset samples with a low score | Ensembling with an MLP second-level model and a geometric mean blending | . Up Next . In Part 2 of this blog series, we will look at the methodology and implementation of training the model and improving it iteratively. . If you have any questions or feedback about this post, I’d be very happy to hear them. Please contact me at my GitHub or Twitter using the links below. . References: . http://dcase.community/challenge2020/index &#8617; . | https://github.com/rbracco/fastai2_audio &#8617; . | https://www.kaggle.com/c/freesound-audio-tagging-2019/overview &#8617; &#8617;2 . | Learning Sound Event Classifiers from Web Audio with Noisy Labels - Fonseca et al. 2019 &#8617; . | https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html &#8617; . | https://scikit-learn.org/stable/modules/model_evaluation.html#label-ranking-average-precision &#8617; . | Fonseca et al. - Audio tagging with noisy labels and minimal supervision. In Proceedings of DCASE2019 Workshop, NYC, US (2019). &#8617; . | https://colab.research.google.com/drive/1AgPdhSp7ttY18O3fEoHOQKlt_3HJDLi8 &#8617; . | https://www.kaggle.com/c/deepfake-detection-challenge/discussion/129521 &#8617; . | https://github.com/pandas-profiling/pandas-profiling &#8617; . | Computational Analysis of Sound Scenes and Events, pg. 22 - Virtanen et al. &#8617; . | https://github.com/muellerzr/Practical-Deep-Learning-for-Coders-2.0/blob/master/Computer%20Vision/04_ImageWoof.ipynb &#8617; . | He, Tong, Zhi Zhang, Hang Zhang, Zhongyue Zhang, Junyuan Xie, and Mu Li. 2018. “Bag of Tricks for Image Classification with Convolutional Neural Networks.” CoRR abs/1812.01187 &#8617; . | Misra, Diganta. 2019. “Mish: A Self Regularized Non-Monotonic Neural Activation Function.” &#8617; . | Liyuan Liu et al. 2019 - On the Variance of the Adaptive Learning rate and Beyond &#8617; . | Zhang, Lucas Hinton, Ba - Lookahead Optimizer: k steps forward, 1 step back &#8617; . | Han Zhang, Ian Goodfellow, Dimitris Metaxas, Augustus Odena 2018 - Self-Attention Generative Adversarial Networks &#8617; . | https://github.com/lRomul/argus-freesound &#8617; . |",
            "url": "https://mikful.github.io/blog/deep%20learning/fastai2/audio/markdown/2020/06/05/Udacity-Capstone-Part-1-Definition-and-Data.html",
            "relUrl": "/deep%20learning/fastai2/audio/markdown/2020/06/05/Udacity-Capstone-Part-1-Definition-and-Data.html",
            "date": " • Jun 5, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi, I’m Mike Fuller, an acoustic engineer who is currently studying an MSc in Artificial Intelligence at the University of Bath, UK. Welcome to my blog about my journey into AI and machine learning. . If you have any queries on any of the posts, or just want to get in touch, please feel free to send me a message at the links provided. .",
          "url": "https://mikful.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://mikful.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}